<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>《Android高性能编程》-多线程 - Tori Zhang</title>

  <!-- Edit site and author settings in `_config.yml` to make the social details your own -->

    <meta content="Tori Zhang" property="og:site_name">
  
    <meta content="《Android高性能编程》-多线程" property="og:title">
  
  
    <meta content="article" property="og:type">
  
  
    <meta content="Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
" property="og:description">
  
  
    <meta content="http://localhost:4000/Android%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" property="og:url">
  
  
    <meta content="2018-04-22T00:00:00+08:00" property="article:published_time">
    <meta content="http://localhost:4000/about/" property="article:author">
  
  
    <meta content="http://localhost:4000/assets/img/blog_head_5.jpeg" property="og:image">
  
  
    
  
  
    
    <meta content="Android" property="article:tag">
    
    <meta content="性能" property="article:tag">
    
  

    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@">
    <meta name="twitter:creator" content="@Tori_Zhang_">
  
    <meta name="twitter:title" content="《Android高性能编程》-多线程">
  
  
    <meta name="twitter:url" content="http://localhost:4000/Android%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B/">
  
  
    <meta name="twitter:description" content="Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
">
  
  
    <meta name="twitter:image:src" content="http://localhost:4000/assets/img/blog_head_5.jpeg">
  

	<meta name="description" content="">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<meta property="og:image" content="">
	<link rel="shortcut icon" href="/assets/img/favicon/favicon.ico" type="image/x-icon">
	<link rel="apple-touch-icon" href="/assets/img/favicon/apple-touch-icon.png">
	<link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicon/apple-touch-icon-72x72.png">
	<link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicon/apple-touch-icon-114x114.png">
	<!-- Chrome, Firefox OS and Opera -->
	<meta name="theme-color" content="#263959">
	<!-- Windows Phone -->
	<meta name="msapplication-navbutton-color" content="#263959">
	<!-- iOS Safari -->
	<meta name="apple-mobile-web-app-status-bar-style" content="#263959">
	<!-- Google Fonts -->
	<link href="https://fonts.googleapis.com/css?family=PT+Serif:400,700" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700" rel="stylesheet">
	<!-- Font Awesome -->
	<link rel="stylesheet" href="/assets/fonts/font-awesome/css/font-awesome.min.css">
	<!-- Styles -->
	<link rel="stylesheet" href="/assets/css/main.css">
</head>

<body>

  <div class="wrapper">
    <aside class="sidebar">
  <header>
    <div class="about">
      <div class="cover-author-image">
        <a href="/"><img src="/assets/img/headicon.jpg" alt="Tori Zhang"></a>
      </div>
      <div class="author-name">Tori Zhang</div>
      <p>Exploring.</p>
    </div>
  </header> <!-- End Header -->
  <footer>
    <section class="contact">
      <h3 class="contact-title">Contact me</h3>
      <ul>
        <li><a href="https://twitter.com/Tori_Zhang_" target="_blank"><i class="fa fa-twitter" aria-hidden="true"></i></a></li>
        <li class="github"><a href="http://github.com/leo1992" target="_blank"><i class="fa fa-github"></i></a></li>
        <li class="email"><a href="mailto:480zhangying@163.com"><i class="fa fa-envelope-o"></i></a></li>
      </ul>
    </section> <!-- End Section Contact -->
    <div class="copyright">
      <p>2018 &copy; Tori Zhang</p>
    </div>
  </footer> <!-- End Footer -->
</aside> <!-- End Sidebar -->
<div class="content-box clearfix">
  <article class="article-page">
  <div class="page-content">
    
    <div class="page-cover-image">
      <img class="page-image" src=/assets/img/blog_head_5.jpeg alt="《Android高性能编程》-多线程">
    </div> <!-- End Page Cover Image -->
    
    <div class="wrap-content">
      <header class="header-page">
        <h1 class="page-title">《Android高性能编程》-多线程</h1>
        <div class="page-date"><span>2018, Apr 22&nbsp;&nbsp;&nbsp;&nbsp;</span></div>
      </header>
      <h1 id="预览">预览</h1>
<h2 id="线程基础">线程基础</h2>
<p>Thread.run()方法并不会创建一个新线程，start()才能开启新线程
Thread.join()方法可以在它的子线程完成时恢复执行状态，在不知道要执行多久时可以调用。（一般情况不会恢复么，或者有没有回调什么的）
线程安全：一个多线程应用程序再共享对象上没有什么并发操作。
每个对象都有一个监视器，线程可以锁定或者解锁它，监视器确保同一时间只会被锁住一次。</p>
<h2 id="android多线程环境">Android多线程环境</h2>
<p>进程的<strong>生命周期</strong>：Foreground, visible（非前台但可见）, service, background, empty（不包含任何组件的进程，它被用作缓存的目的，以加快应用程序未来的恢复）
进程名以 <strong>：</strong>开始代表为该应用的私有进程，以<strong>小写字母</strong>开始为可共享进程。</p>
<h2 id="android应用程序线程">Android应用程序线程</h2>
<p><strong>UI线程</strong>：唯一的可以管理用户界面的线程，原因：1.因为ui不是线程安全的； 2. 加快ui，加锁和解锁操作消耗太大。
<strong>工作线程</strong>
<strong>binder线程</strong>：线程间通信。不需要直接处理这个线程，Android接口定义语言（AIDL）</p>
<h2 id="android线程消息">Android线程消息</h2>
<p>Message或Runnable；MessageQueue; looper；Handler
只有主线程有自己的Looper，如果需要让两个线程进行通信，必须指定looper对象（Looper.prepare()）并创建MQ。
空的Handler构造器会与改Hander创建时所在线程的Looper关联起来，所以new Handler() 的实例化方法只能再主线程中进行（只有主线程有自己的Looper）
<img src="https://img-blog.csdn.net/2018042212371948?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xlbzE5OTIwNzMx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="线程之间的消息传递，照书画的添加了说明" /></p>
<h1 id="最佳实践">最佳实践</h1>
<h2 id="线程">线程</h2>
<p>在使用线程时，要避免在循环中使用同步，因为获取或释放锁的操作代价高昂</p>
<h2 id="handlerthread">HandlerThread</h2>
<p>handlerThread=Handle+Looper+MessageQueue
onLooperPrepare方法
与传统线程不同，handlerthread是可以被重用的，一直处于活跃状态，知道handerthread.quit方法被调用。
当我们需要一个<strong>可供一直使用的线程</strong>时可以使用</p>
<h2 id="asynctask">AsyncTask</h2>
<p>并不是一个线程框架，只是一个用于工作线程和ui线程之间通信的帮助类。
<strong>回调方法</strong>
onPreExecute() 启动后台之前
onProgressUpdate() ui线程，处理ui更新
onPostExecute()  处理从工作线程返回的结果  -&gt; FINISHED
onCancelled()
<strong>状态</strong>：PENDING, RUNNING, FINISHED
<strong>Executor对象，执行类型</strong>：
SERIAL_EXECUTOR（顺序依次执行一个）——&gt; execute()
THREAD_POOL_EXECUTOR(并发)  executeOnExecutor()
<strong>Executor对象，创建</strong>：
newCachedThreadPool：数量不固定，检查当前有没有，没有创建并缓存一个
newFixedThreadPool：数量固定，同上
newScheduledThreadPool：按预定时间调度，用于执行定时任务和具有固定周期的重复任务
newSingleThreadExecutor：只有一个线程。用于将外界任务统一到一个线程池中，线程之间不需要处理线程同步问题。
newSingleThreadScheduledExecutor
<strong>用处：</strong>用来处理工作线程与ui的同步，如果不需要通知用户或处理ui，没必要使用。一般的Thread足够并且性能比它要好。如果参数全为空可以考虑不用。
<strong>注意：</strong>有时候存在ui不存在的情况，但仍然再执行，此时要考虑缓存结果。</p>
<h2 id="loader">Loader</h2>
<p>适合异步操作，它是生命周期独立的，与activity或fragment的配置导致的销毁没有关系，仍然缓存结果通知最新创建的activity或fragment，使用的是application的context因此减少了activity泄漏风险。
<strong>LoaderManager</strong>：由id确认
**LoaderCallBack<D>**:create,finish,reset
平台提供的Loader：
**AsyncTaskLoader**：使用包装过的AsycnTask做后台工作，在任务完成后传数据到ui线程。在获取数据时使用
**CursorLoader**:AsyncTaskLoader的一个实现，专门用于从ContentProvider检索数据的工具
**何时使用**：不用担心activity或fragment的生命周期，并且为用户缓存数据</D></p>
<h2 id="service">Service</h2>
<p>它默认在ui线程中执行，所以永远不要启动一个长时间运行的操作
<strong>何时使用</strong>：
不需要用户交互的操作可以用<strong>Service</strong>
处理多个并发请求时可以用<strong>Started Service</strong>，但用户需要设计自己的多线程策略
如果希望某个组件与Service直接通信，可以用<strong>BoundService</strong>，维持了两个绑定组件之间的独立性
当需要在单独线程中，顺序执行一系列后台操作时，可以用<strong>IntentService</strong>，不需要处理Service的生命周期，不影响UI</p>
<h4 id="started-service">Started Service</h4>
<p>startService或intent启动，直到调用stop的时候才会停止
startId
进程被销毁后告诉系统如何处理，返回值：
START_STICKY; 重建，此时发送的intent为空，因此在start时需要判断intent
START_NOT_STICK;  不重建
START_REDELIVER_INTENT; 被非stop的情况下被终止时，在被重启时，会受到销毁前的最后一个intent。需要知道什么操作导致中断时，可以用这个。
作为参数
0
START_FLAG_REDELIVERY : 按返回策略重新递送，已经递送过
START_FLAG_READY： 在递送时被终止</p>
<h4 id="boundservice">BoundService</h4>
<p>通过bind启动，只要绑定的外部组件存在，它就活跃，否则被销毁
持有一个对客户端的引用.
onBind只在绑定第一个客户端时被调用
unBind在最后一个客户端解绑时被调用</p>
<h4 id="intentservice">IntentService</h4>
<p>包装了一个单独的后台线程，处理不同的请求，与intent相关，传入的放入一个队列，执行完Service会被自动销毁。只有后台线程在执行操作时它才是活跃状态。
用handlerInent来处理intent（不是startcommond），执行在后台线程中
默认为START_NOT_STICKY
不能被绑定</p>
<h2 id="进程间通信">进程间通信</h2>
<h4 id="远程过程调用rpc">远程过程调用RPC</h4>
<p>使得本地线程中的客户点成，能像调用本地方法一样，调用远程方法。
客户端（marshalling）-&gt; Binder -&gt; 服务端 （demarshaling）—&gt; 客户端
数据要实现parcelable接口</p>
<h4 id="aidl">AIDL</h4>
<p>用的时候再说吧，标注在书里了</p>
<h2 id="先进的技术">先进的技术</h2>
<h4 id="broadcastreceiver异步技术">BroadcastReceiver异步技术</h4>
<p>只在onreceive方法中活跃，用于接受消息，生命周期断，适合用于启动一个后台线程
延长生命周期：goAsync方法，返回pendingResult 会持续到pendingResult的finish方法调用。</p>
<h4 id="contentprovider-异步技术">ContentProvider 异步技术</h4>
<p>用于再主要组件之间、进程之间、应用之间共享数据。目的是持有一个共享信息的数据库。不能被直接访问，要用contentresolver对象进行数据处理。
SQLite是带锁的
AsyncQueryHandler：包装了contentresolver，以便再ContentProvider上开启异步操作。它能将ui线程从不必要的操作中释放出来，让一个工作线程来处理contentresolver，提升ui性能。</p>
<h4 id="重复性任务">重复性任务</h4>
<p>Timer：周期性任务，适用于短时间周期性任务
ScheduledExecutorService：定时重复任务。executor框架的特殊实现，更强大。
AlarmManger：在某个特殊事件启动一个新组建，比其他类更高效，因为依赖于系统的闹铃服务，不适合短期任务。</p>
<h1 id="调试工具">调试工具</h1>
<h2 id="strictmode">StrictMode</h2>

      <div class="page-footer">
        <div class="page-share">
          <a href="https://twitter.com/intent/tweet?text=《Android高性能编程》-多线程&url=http://localhost:4000/Android%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="Share on Twitter" rel="nofollow" target="_blank">Twitter</a>
          <a href="https://facebook.com/sharer.php?u=http://localhost:4000/Android%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="Share on Facebook" rel="nofollow" target="_blank">Facebook</a>
          <a href="https://plus.google.com/share?url=http://localhost:4000/Android%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="Share on Google+" rel="nofollow" target="_blank">Google+</a>
        </div>
        <div class="page-tag">
          
            <a href="/tags#Android" class="tag">&#35; Android</a>
          
            <a href="/tags#性能" class="tag">&#35; 性能</a>
          
        </div>
      </div>
      <section class="comment-area">
  <div class="comment-wrapper">
    
    <div id="disqus_thread" class="article-comments"></div>
    <script>
      (function() {
          var d = document, s = d.createElement('script');
          s.src = '//mr-brown.disqus.com/embed.js';
          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    
  </div>
</section> <!-- End Comment Area -->

    </div> <!-- End Wrap Content -->
  </div> <!-- End Page Content -->
</article> <!-- End Article Page -->

</div>

  </div>
  
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', '', 'auto');
  ga('send', 'pageview');
</script> <!-- End Analytics -->

</body>
</html>
